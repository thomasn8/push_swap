_________________________________________________________________
https://www.jesuisundev.com/comprendre-les-algorithmes-de-tri-en-7-minutes/

-Tri par insertion
	-> lent avec beaucoup de données
	-> efficace avec peu de données
	-> Logique :
		On passe sur chacun des éléments à trier et on l’insère directement à la place où il devrait être
		Pour faire cette insertion, on va simplement comparer l’élément courant avec chaque élément déjà trié sur la gauche.

-Tri fusion (merge sort)
	-> + complexe
	-> efficace sur des grandes séquences de données
	-> Logique :
		On va commencer par diviser le tableau en deux éléments égaux.
		On va recommencer la même chose jusqu’à atteindre un seul élément par séparation.
		Ensuite, on va refusionner les éléments séparés de façon récursive en les triant à chaque niveau.

-Tri rapide (quick sort)


_________________________________________________________________
https://fr.wikipedia.org/wiki/Algorithme_de_tri

Complexité algorithmique :

La complexité temporelle (en moyenne ou dans le pire des cas) mesure le nombre d'opérations élémentaires effectuées pour trier une collection d'éléments. C'est un critère majeur pour comparer les algorithmes de tri, puisque c'est une estimation directe du temps d'exécution de l'algorithme. Dans le cas des algorithmes de tri par comparaison, la complexité en temps est le plus souvent assimilable au nombre de comparaisons effectuées, la comparaison et l'échange éventuel de deux valeurs s'effectuant en temps constant.

La complexité spatiale (en moyenne ou dans le pire des cas) représente, quant à elle, la quantité de mémoire dont va avoir besoin l'algorithme pour s'exécuter.

Certains algorithmes de tri simples ont une complexité en temps quadratique, i.e. T ( n ) = O ( n 2 ) 
Tandis que d'autres, plus élaborés, ont une complexité quasi linéaire : T ( n ) = O ( n log ⁡ ( n ) ) 


_________________________________________________________________
https://fr.wikipedia.org/wiki/Tri_de_nombres_entiers

La possibilité d'effectuer une arithmétique sur les clés permet aux algorithmes de tri d'entiers d'être plus rapides que les algorithmes de tri par comparaison, en fonction du détail des opérations autorisées dans le modèle de calcul et de la taille des entiers à trier.

-Tri pigeonhole
-Tri comptage
-Tri par base


_________________________________________________________________
https://fr.wikipedia.org/wiki/Tri_par_insertion
Le tri par insertion est cependant considéré comme l'algorithme le plus efficace sur des entrées de petite taille. Il est aussi efficace lorsque les données sont déjà presque triées. Pour ces raisons, il est utilisé en pratique en combinaison avec d'autres méthodes comme le tri rapide.

Combinaison avec d'autres tris
En pratique, sur les petites entrées, en dessous d'une taille critique K (qui dépend de l'implémentation et de la machine utilisée), les algorithmes de tri en O ( n log ⁡ n ) {\displaystyle O(n\,\log n)} O(n\,\log n) basés sur la méthode « diviser pour régner » (tri fusion, tri rapide) sont moins efficaces que le tri par insertion. Dans ce type d'algorithmes, plutôt que de diviser récursivement l'entrée jusqu'à avoir des sous-problèmes élémentaires de taille 1 ou 2, on peut s'arrêter dès que les sous-problèmes ont une taille inférieure à K et les traiter avec le tri par insertion.


https://fr.wikipedia.org/wiki/Tri_fusion

https://fr.wikipedia.org/wiki/Tri_rapide
C'est en pratique un des tris les plus rapides, et donc un des plus utilisés. Le pire des cas est en effet peu probable lorsque l'algorithme est correctement mis en œuvre et il est possible de s'en prémunir définitivement avec la variante Introsort.

Le tri rapide ne peut cependant pas tirer avantage du fait que l'entrée est déjà presque triée. Dans ce cas particulier, il est plus avantageux d'utiliser le tri par insertion ou l'algorithme smoothsort.